C++协程的核心是用户态上下文切换,通过编译器生成代码保存/恢复执行状态,避免内核线程切换的开销。
Linux下依赖手动汇编和用户态栈管理;
Windows下则复用系统Fiber机制;
两者均遵循C++20标准的接口规范,但底层实现细节因系统特性而异。
这种设计让协程在异步编程中既能保持代码简洁,又能兼顾高性能。




一、Linux下的C++协程实现
Linux系统本身没有专门为协程提供内核接口,C++编译器（如GCC、Clang）通常通过用户态库+汇编指令实现上下文切换,核心依赖以下技术:
1. 上下文切换:基于ucontext或直接汇编
    ucontext库（早期实现）:Linux的glibc提供了ucontext_t结构体（存储上下文）和getcontext（保存当前上下文）、setcontext（恢复上下文）、swapcontext（切换上下文）等函数。
    编译器可基于此实现协程切换,但ucontext性能较差（需保存完整寄存器集）,现代实现多弃用。
    直接汇编优化（主流实现）:通过汇编指令手动保存/恢复关键寄存器（如rsp、rip、rbx、rbp等）,减少不必要的操作。
    例如,GCC的协程实现中,上下文切换仅保存必要的寄存器,而非完整的ucontext_t,大幅提升性能。

2. 栈管理:分段栈或固定栈
    协程需要独立的栈空间（存储局部变量）,Linux下的实现通常有两种方式:
    固定大小栈:创建协程时分配一块固定大小的内存作为栈（如8KB）,优点是简单,缺点是栈溢出风险高。
    分段栈（segmented stack）:栈空间按需动态增长（类似线程的栈）,通过编译器在函数调用时插入栈检查逻辑,不足时自动分配新的栈段,避免溢出。Clang的协程实现支持分段栈。

3. 编译器实现细节（以GCC为例）
   GCC对C++协程的支持基于libstdc++和内部组件:
    协程函数被调用时,编译器会生成代码:在堆上分配协程状态（包含Promise对象、栈指针、寄存器快照等）。
    遇到co_await时,编译器插入代码:保存当前寄存器和栈状态到协程状态,调用await_suspend（可等待对象的方法）,然后切换到调用者的上下文。
    调用coroutine_handle::resume()时,从协程状态中恢复寄存器和栈,继续执行co_await之后的代码。

二、Windows下的C++协程实现
Windows提供了更贴近协程的系统机制（如纤维）,MSVC（微软编译器）的C++协程实现通常基于这些机制优化:
    1. 上下文切换:基于纤维（Fiber）API
     Windows的纤维（Fiber） 是一种用户态轻量级线程（内核不可见）,提供了专门的上下文切换接口:
    CreateFiber:创建纤维（分配栈和上下文）。
    SwitchToFiber:切换到指定纤维（保存当前纤维上下文,加载目标纤维上下文）。
    DeleteFiber:销毁纤维。
    MSVC的协程实现可复用Fiber的上下文切换逻辑,co_await暂停时通过SwitchToFiber切换到调用者上下文,resume()时再切回,省去手动汇编实现的成本。

   2. 栈管理:基于Windows线程栈机制
    Windows的协程栈通常复用系统的栈管理能力:
    协程栈可基于线程栈的"预留-提交"机制（先预留虚拟地址空间,实际使用时再提交物理内存）,实现动态增长。
    MSVC默认给协程分配较小的初始栈（如4KB）,并在栈接近溢出时自动扩展（通过异常处理机制检测栈溢出,然后扩展栈空间）。

   3. 编译器实现细节（以MSVC为例）
    MSVC的协程实现深度整合Windows系统特性:
    协程状态分配在堆上,包含Promise对象、Fiber上下文指针、栈信息等。
    co_await触发时,通过SwitchToFiber切换到调用者的Fiber（或线程）,同时将协程状态挂起。
    恢复时,调用coroutine_handle::resume()会触发SwitchToFiber切回协程的Fiber,从暂停点继续执行。
